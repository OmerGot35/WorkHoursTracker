import React, { useState, useEffect } from 'react';
import { Calendar, Clock, Calculator, AlertCircle, ChevronLeft, ChevronRight, Download, LineChart as ChartIcon, Table } from 'lucide-react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { LineChart, XAxis, YAxis, CartesianGrid, Line, Tooltip, Legend } from 'recharts';

const VIEWS = {
  ENTRY: 'entry',
  DASHBOARD: 'dashboard',
  RAW: 'raw'
};

const WorkHoursTracker = () => {
  const [currentView, setCurrentView] = useState(VIEWS.ENTRY);
  // ... [previous state declarations] ...

  const renderNavigation = () => (
    <div className="bg-white border-b mb-6">
      <div className="max-w-4xl mx-auto">
        <nav className="flex space-x-4 p-4">
          <button 
            onClick={() => setCurrentView(VIEWS.ENTRY)}
            className={`px-4 py-2 rounded-lg flex items-center gap-2 ${currentView === VIEWS.ENTRY ? 'bg-blue-100 text-blue-700' : 'hover:bg-gray-100'}`}
          >
            <Clock className="w-4 h-4" />
            Entry
          </button>
          <button 
            onClick={() => setCurrentView(VIEWS.DASHBOARD)}
            className={`px-4 py-2 rounded-lg flex items-center gap-2 ${currentView === VIEWS.DASHBOARD ? 'bg-blue-100 text-blue-700' : 'hover:bg-gray-100'}`}
          >
            <ChartIcon className="w-4 h-4" />
            Dashboard
          </button>
          <button 
            onClick={() => setCurrentView(VIEWS.RAW)}
            className={`px-4 py-2 rounded-lg flex items-center gap-2 ${currentView === VIEWS.RAW ? 'bg-blue-100 text-blue-700' : 'hover:bg-gray-100'}`}
          >
            <Table className="w-4 h-4" />
            Raw Data
          </button>
        </nav>
      </div>
    </div>
  );

  const getMonthlyTrends = () => {
    const trends = {};
    
    entries.forEach(entry => {
      const date = new Date(entry.date);
      const monthYear = `${date.getFullYear()}-${date.getMonth() + 1}`;
      const workplace = entry.workplace;
      
      if (!trends[monthYear]) {
        trends[monthYear] = {};
      }
      if (!trends[monthYear][workplace]) {
        trends[monthYear][workplace] = {
          hours: 0,
          pay: 0
        };
      }
      
      const workplaceData = workplaces.find(w => w.name === workplace);
      const rate = entry.isSaturday ? workplaceData.saturdayRate : workplaceData.weekdayRate;
      
      trends[monthYear][workplace].hours += parseInt(entry.hours);
      trends[monthYear][workplace].pay += parseInt(entry.hours) * rate;
    });
    
    return Object.entries(trends).map(([monthYear, data]) => ({
      month: monthYear,
      ...Object.fromEntries(
        Object.entries(data).map(([workplace, stats]) => [
          `${workplace}_hours`, stats.hours
        ])
      ),
      ...Object.fromEntries(
        Object.entries(data).map(([workplace, stats]) => [
          `${workplace}_pay`, stats.pay
        ])
      )
    })).sort((a, b) => a.month.localeCompare(b.month));
  };

  const renderDashboard = () => {
    const trendData = getMonthlyTrends();
    
    return (
      <div className="space-y-6">
        <Card className="shadow-lg">
          <CardHeader>
            <CardTitle>Monthly Hours Trend</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="h-64">
              <LineChart data={trendData} width={800} height={250} margin={{ top: 5, right: 30, left: 20, bottom: 5 }}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="month" />
                <YAxis />
                <Tooltip />
                <Legend />
                {workplaces.map((workplace, index) => (
                  <Line 
                    key={workplace.name}
                    type="monotone"
                    dataKey={`${workplace.name}_hours`}
                    stroke={`hsl(${index * 120}, 70%, 50%)`}
                    name={`${workplace.name} Hours`}
                  />
                ))}
              </LineChart>
            </div>
          </CardContent>
        </Card>

        <Card className="shadow-lg">
          <CardHeader>
            <CardTitle>Monthly Earnings Trend</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="h-64">
              <LineChart data={trendData} width={800} height={250} margin={{ top: 5, right: 30, left: 20, bottom: 5 }}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="month" />
                <YAxis />
                <Tooltip />
                <Legend />
                {workplaces.map((workplace, index) => (
                  <Line 
                    key={workplace.name}
                    type="monotone"
                    dataKey={`${workplace.name}_pay`}
                    stroke={`hsl(${index * 120}, 70%, 50%)`}
                    name={`${workplace.name} Pay`}
                  />
                ))}
              </LineChart>
            </div>
          </CardContent>
        </Card>
      </div>
    );
  };

  const renderRawEntries = () => {
    const entriesByMonth = {};
    
    entries.forEach(entry => {
      const date = new Date(entry.date);
      const monthYear = `${date.getFullYear()}-${date.getMonth() + 1}`;
      
      if (!entriesByMonth[monthYear]) {
        entriesByMonth[monthYear] = [];
      }
      entriesByMonth[monthYear].push(entry);
    });

    return (
      <div className="space-y-8">
        {Object.entries(entriesByMonth)
          .sort(([a], [b]) => b.localeCompare(a))
          .map(([monthYear, monthEntries]) => (
            <Card key={monthYear} className="shadow-lg">
              <CardHeader>
                <CardTitle>{new Date(monthYear).toLocaleString('default', { month: 'long', year: 'numeric' })}</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="overflow-x-auto">
                  <table className="w-full">
                    <thead>
                      <tr className="bg-gray-50">
                        <th className="p-2 text-left">Date</th>
                        <th className="p-2 text-left">Workplace</th>
                        <th className="p-2 text-left">Hours</th>
                        <th className="p-2 text-left">Day Type</th>
                        <th className="p-2 text-left">Pay</th>
                      </tr>
                    </thead>
                    <tbody>
                      {monthEntries
                        .sort((a, b) => new Date(b.date) - new Date(a.date))
                        .map(entry => {
                          const workplace = workplaces.find(w => w.name === entry.workplace);
                          const rate = entry.isSaturday ? workplace.saturdayRate : workplace.weekdayRate;
                          const pay = parseInt(entry.hours) * rate;
                          
                          return (
                            <tr key={entry.id} className="border-t">
                              <td className="p-2">{new Date(entry.date).toLocaleDateString()}</td>
                              <td className="p-2">{entry.workplace}</td>
                              <td className="p-2">{entry.hours}</td>
                              <td className="p-2">{entry.isSaturday ? 'Saturday' : 'Weekday'}</td>
                              <td className="p-2">â‚ª{pay}</td>
                            </tr>
                          );
                        })}
                    </tbody>
                  </table>
                </div>
              </CardContent>
            </Card>
          ))}
      </div>
    );
  };

  return (
    <div className="min-h-screen bg-gray-50">
      {renderNavigation()}
      
      <div className="max-w-4xl mx-auto p-6">
        {currentView === VIEWS.ENTRY && (
          // ... [previous entry form code] ...
        )}
        
        {currentView === VIEWS.DASHBOARD && renderDashboard()}
        
        {currentView === VIEWS.RAW && renderRawEntries()}
      </div>
    </div>
  );
};

export default WorkHoursTracker;
